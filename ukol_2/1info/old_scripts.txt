def get_tile_coordinates_by_name(self, tile_name, state):
        for t_name, xy in state.iteritems():
            if tile_name == t_name:
                return xy

    def _find_best_state(self, new_states):
        """
        Select a state with the lowest h value.
        If there are more states with same value, choose the one which will place a non-zero title on the right place.
        """
        return min(new_states, key=lambda x: x['h_value'])
        """
        min_h = float("inf")
        # Get the lowest h value.
        for state in new_states:
            if state['h_value'] < min_h:
                min_h = state['h_value']
        # Remove states with a higher h value.
        min_states = []
        for state in new_states:
            if state['h_value'] == min_h:
                min_states.append(state)
        # If there is only one state with the value, return the result.
        #print min_states
        if len(min_states) == 1:
            return min_states[0]
        # Otherwise search the states and if necessary, skip the zero tile.
        for state in min_states:
            if state['moved_tile'] == self.solution_path[-1]['tiles'][0]:
                continue
            else:
                return state
        """